// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_message_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_message_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_message_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_message_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_message_2eproto;
class ArucoMarker;
struct ArucoMarkerDefaultTypeInternal;
extern ArucoMarkerDefaultTypeInternal _ArucoMarker_default_instance_;
class Body;
struct BodyDefaultTypeInternal;
extern BodyDefaultTypeInternal _Body_default_instance_;
class Envelope;
struct EnvelopeDefaultTypeInternal;
extern EnvelopeDefaultTypeInternal _Envelope_default_instance_;
class Point2f;
struct Point2fDefaultTypeInternal;
extern Point2fDefaultTypeInternal _Point2f_default_instance_;
class TrackingData;
struct TrackingDataDefaultTypeInternal;
extern TrackingDataDefaultTypeInternal _TrackingData_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template <>
::ArucoMarker* Arena::CreateMaybeMessage<::ArucoMarker>(Arena*);
template <>
::Body* Arena::CreateMaybeMessage<::Body>(Arena*);
template <>
::Envelope* Arena::CreateMaybeMessage<::Envelope>(Arena*);
template <>
::Point2f* Arena::CreateMaybeMessage<::Point2f>(Arena*);
template <>
::TrackingData* Arena::CreateMaybeMessage<::TrackingData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE


// ===================================================================


// -------------------------------------------------------------------

class Envelope final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Envelope) */ {
 public:
  inline Envelope() : Envelope(nullptr) {}
  ~Envelope() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Envelope(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Envelope(const Envelope& from);
  Envelope(Envelope&& from) noexcept
    : Envelope() {
    *this = ::std::move(from);
  }

  inline Envelope& operator=(const Envelope& from) {
    CopyFrom(from);
    return *this;
  }
  inline Envelope& operator=(Envelope&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Envelope& default_instance() {
    return *internal_default_instance();
  }
  static inline const Envelope* internal_default_instance() {
    return reinterpret_cast<const Envelope*>(
               &_Envelope_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Envelope& a, Envelope& b) {
    a.Swap(&b);
  }
  inline void Swap(Envelope* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Envelope* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Envelope* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Envelope>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Envelope& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Envelope& from) {
    Envelope::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Envelope* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Envelope";
  }
  protected:
  explicit Envelope(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackingDataFieldNumber = 1,
  };
  // repeated .TrackingData trackingData = 1;
  int trackingdata_size() const;
  private:
  int _internal_trackingdata_size() const;

  public:
  void clear_trackingdata() ;
  ::TrackingData* mutable_trackingdata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TrackingData >*
      mutable_trackingdata();
  private:
  const ::TrackingData& _internal_trackingdata(int index) const;
  ::TrackingData* _internal_add_trackingdata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::TrackingData>& _internal_trackingdata() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::TrackingData>* _internal_mutable_trackingdata();
  public:
  const ::TrackingData& trackingdata(int index) const;
  ::TrackingData* add_trackingdata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TrackingData >&
      trackingdata() const;
  // @@protoc_insertion_point(class_scope:Envelope)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TrackingData > trackingdata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};// -------------------------------------------------------------------

class TrackingData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TrackingData) */ {
 public:
  inline TrackingData() : TrackingData(nullptr) {}
  ~TrackingData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TrackingData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackingData(const TrackingData& from);
  TrackingData(TrackingData&& from) noexcept
    : TrackingData() {
    *this = ::std::move(from);
  }

  inline TrackingData& operator=(const TrackingData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackingData& operator=(TrackingData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackingData& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackingData* internal_default_instance() {
    return reinterpret_cast<const TrackingData*>(
               &_TrackingData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TrackingData& a, TrackingData& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackingData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackingData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackingData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackingData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackingData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackingData& from) {
    TrackingData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackingData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "TrackingData";
  }
  protected:
  explicit TrackingData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArucoMarkersFieldNumber = 2,
    kBodiesFieldNumber = 3,
    kCameraNameFieldNumber = 1,
  };
  // repeated .ArucoMarker arucoMarkers = 2;
  int arucomarkers_size() const;
  private:
  int _internal_arucomarkers_size() const;

  public:
  void clear_arucomarkers() ;
  ::ArucoMarker* mutable_arucomarkers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ArucoMarker >*
      mutable_arucomarkers();
  private:
  const ::ArucoMarker& _internal_arucomarkers(int index) const;
  ::ArucoMarker* _internal_add_arucomarkers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ArucoMarker>& _internal_arucomarkers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ArucoMarker>* _internal_mutable_arucomarkers();
  public:
  const ::ArucoMarker& arucomarkers(int index) const;
  ::ArucoMarker* add_arucomarkers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ArucoMarker >&
      arucomarkers() const;
  // repeated .Body bodies = 3;
  int bodies_size() const;
  private:
  int _internal_bodies_size() const;

  public:
  void clear_bodies() ;
  ::Body* mutable_bodies(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Body >*
      mutable_bodies();
  private:
  const ::Body& _internal_bodies(int index) const;
  ::Body* _internal_add_bodies();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::Body>& _internal_bodies() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::Body>* _internal_mutable_bodies();
  public:
  const ::Body& bodies(int index) const;
  ::Body* add_bodies();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Body >&
      bodies() const;
  // string cameraName = 1;
  void clear_cameraname() ;
  const std::string& cameraname() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cameraname(Arg_&& arg, Args_... args);
  std::string* mutable_cameraname();
  PROTOBUF_NODISCARD std::string* release_cameraname();
  void set_allocated_cameraname(std::string* ptr);

  private:
  const std::string& _internal_cameraname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cameraname(
      const std::string& value);
  std::string* _internal_mutable_cameraname();

  public:
  // @@protoc_insertion_point(class_scope:TrackingData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ArucoMarker > arucomarkers_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Body > bodies_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cameraname_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};// -------------------------------------------------------------------

class ArucoMarker final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ArucoMarker) */ {
 public:
  inline ArucoMarker() : ArucoMarker(nullptr) {}
  ~ArucoMarker() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ArucoMarker(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArucoMarker(const ArucoMarker& from);
  ArucoMarker(ArucoMarker&& from) noexcept
    : ArucoMarker() {
    *this = ::std::move(from);
  }

  inline ArucoMarker& operator=(const ArucoMarker& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArucoMarker& operator=(ArucoMarker&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArucoMarker& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArucoMarker* internal_default_instance() {
    return reinterpret_cast<const ArucoMarker*>(
               &_ArucoMarker_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ArucoMarker& a, ArucoMarker& b) {
    a.Swap(&b);
  }
  inline void Swap(ArucoMarker* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArucoMarker* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArucoMarker* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArucoMarker>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArucoMarker& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ArucoMarker& from) {
    ArucoMarker::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArucoMarker* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ArucoMarker";
  }
  protected:
  explicit ArucoMarker(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated .Point2f points = 2;
  int points_size() const;
  private:
  int _internal_points_size() const;

  public:
  void clear_points() ;
  ::Point2f* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Point2f >*
      mutable_points();
  private:
  const ::Point2f& _internal_points(int index) const;
  ::Point2f* _internal_add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::Point2f>& _internal_points() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::Point2f>* _internal_mutable_points();
  public:
  const ::Point2f& points(int index) const;
  ::Point2f* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Point2f >&
      points() const;
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:ArucoMarker)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Point2f > points_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};// -------------------------------------------------------------------

class Point2f final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Point2f) */ {
 public:
  inline Point2f() : Point2f(nullptr) {}
  ~Point2f() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Point2f(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Point2f(const Point2f& from);
  Point2f(Point2f&& from) noexcept
    : Point2f() {
    *this = ::std::move(from);
  }

  inline Point2f& operator=(const Point2f& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point2f& operator=(Point2f&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Point2f& default_instance() {
    return *internal_default_instance();
  }
  static inline const Point2f* internal_default_instance() {
    return reinterpret_cast<const Point2f*>(
               &_Point2f_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Point2f& a, Point2f& b) {
    a.Swap(&b);
  }
  inline void Swap(Point2f* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point2f* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Point2f* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Point2f>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Point2f& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Point2f& from) {
    Point2f::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point2f* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Point2f";
  }
  protected:
  explicit Point2f(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // @@protoc_insertion_point(class_scope:Point2f)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};// -------------------------------------------------------------------

class Body final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Body) */ {
 public:
  inline Body() : Body(nullptr) {}
  ~Body() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Body(const Body& from);
  Body(Body&& from) noexcept
    : Body() {
    *this = ::std::move(from);
  }

  inline Body& operator=(const Body& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body& operator=(Body&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body* internal_default_instance() {
    return reinterpret_cast<const Body*>(
               &_Body_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Body& a, Body& b) {
    a.Swap(&b);
  }
  inline void Swap(Body* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Body& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Body& from) {
    Body::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Body* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Body";
  }
  protected:
  explicit Body(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 1,
  };
  // repeated .Point2f points = 1;
  int points_size() const;
  private:
  int _internal_points_size() const;

  public:
  void clear_points() ;
  ::Point2f* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Point2f >*
      mutable_points();
  private:
  const ::Point2f& _internal_points(int index) const;
  ::Point2f* _internal_add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::Point2f>& _internal_points() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::Point2f>* _internal_mutable_points();
  public:
  const ::Point2f& points(int index) const;
  ::Point2f* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Point2f >&
      points() const;
  // @@protoc_insertion_point(class_scope:Body)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Point2f > points_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Envelope

// repeated .TrackingData trackingData = 1;
inline int Envelope::_internal_trackingdata_size() const {
  return _impl_.trackingdata_.size();
}
inline int Envelope::trackingdata_size() const {
  return _internal_trackingdata_size();
}
inline void Envelope::clear_trackingdata() {
  _internal_mutable_trackingdata()->Clear();
}
inline ::TrackingData* Envelope::mutable_trackingdata(int index) {
  // @@protoc_insertion_point(field_mutable:Envelope.trackingData)
  return _internal_mutable_trackingdata()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TrackingData >*
Envelope::mutable_trackingdata() {
  // @@protoc_insertion_point(field_mutable_list:Envelope.trackingData)
  return _internal_mutable_trackingdata();
}
inline const ::TrackingData& Envelope::_internal_trackingdata(int index) const {
  return _internal_trackingdata().Get(index);
}
inline const ::TrackingData& Envelope::trackingdata(int index) const {
  // @@protoc_insertion_point(field_get:Envelope.trackingData)
  return _internal_trackingdata(index);
}
inline ::TrackingData* Envelope::_internal_add_trackingdata() {
  return _internal_mutable_trackingdata()->Add();
}
inline ::TrackingData* Envelope::add_trackingdata() {
  ::TrackingData* _add = _internal_add_trackingdata();
  // @@protoc_insertion_point(field_add:Envelope.trackingData)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TrackingData >&
Envelope::trackingdata() const {
  // @@protoc_insertion_point(field_list:Envelope.trackingData)
  return _internal_trackingdata();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::TrackingData>&
Envelope::_internal_trackingdata() const {
  return _impl_.trackingdata_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::TrackingData>*
Envelope::_internal_mutable_trackingdata() {
  return &_impl_.trackingdata_;
}

// -------------------------------------------------------------------

// TrackingData

// string cameraName = 1;
inline void TrackingData::clear_cameraname() {
  _impl_.cameraname_.ClearToEmpty();
}
inline const std::string& TrackingData::cameraname() const {
  // @@protoc_insertion_point(field_get:TrackingData.cameraName)
  return _internal_cameraname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrackingData::set_cameraname(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.cameraname_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TrackingData.cameraName)
}
inline std::string* TrackingData::mutable_cameraname() {
  std::string* _s = _internal_mutable_cameraname();
  // @@protoc_insertion_point(field_mutable:TrackingData.cameraName)
  return _s;
}
inline const std::string& TrackingData::_internal_cameraname() const {
  return _impl_.cameraname_.Get();
}
inline void TrackingData::_internal_set_cameraname(const std::string& value) {
  ;


  _impl_.cameraname_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackingData::_internal_mutable_cameraname() {
  ;
  return _impl_.cameraname_.Mutable( GetArenaForAllocation());
}
inline std::string* TrackingData::release_cameraname() {
  // @@protoc_insertion_point(field_release:TrackingData.cameraName)
  return _impl_.cameraname_.Release();
}
inline void TrackingData::set_allocated_cameraname(std::string* value) {
  _impl_.cameraname_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cameraname_.IsDefault()) {
          _impl_.cameraname_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TrackingData.cameraName)
}

// repeated .ArucoMarker arucoMarkers = 2;
inline int TrackingData::_internal_arucomarkers_size() const {
  return _impl_.arucomarkers_.size();
}
inline int TrackingData::arucomarkers_size() const {
  return _internal_arucomarkers_size();
}
inline void TrackingData::clear_arucomarkers() {
  _internal_mutable_arucomarkers()->Clear();
}
inline ::ArucoMarker* TrackingData::mutable_arucomarkers(int index) {
  // @@protoc_insertion_point(field_mutable:TrackingData.arucoMarkers)
  return _internal_mutable_arucomarkers()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ArucoMarker >*
TrackingData::mutable_arucomarkers() {
  // @@protoc_insertion_point(field_mutable_list:TrackingData.arucoMarkers)
  return _internal_mutable_arucomarkers();
}
inline const ::ArucoMarker& TrackingData::_internal_arucomarkers(int index) const {
  return _internal_arucomarkers().Get(index);
}
inline const ::ArucoMarker& TrackingData::arucomarkers(int index) const {
  // @@protoc_insertion_point(field_get:TrackingData.arucoMarkers)
  return _internal_arucomarkers(index);
}
inline ::ArucoMarker* TrackingData::_internal_add_arucomarkers() {
  return _internal_mutable_arucomarkers()->Add();
}
inline ::ArucoMarker* TrackingData::add_arucomarkers() {
  ::ArucoMarker* _add = _internal_add_arucomarkers();
  // @@protoc_insertion_point(field_add:TrackingData.arucoMarkers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ArucoMarker >&
TrackingData::arucomarkers() const {
  // @@protoc_insertion_point(field_list:TrackingData.arucoMarkers)
  return _internal_arucomarkers();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ArucoMarker>&
TrackingData::_internal_arucomarkers() const {
  return _impl_.arucomarkers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::ArucoMarker>*
TrackingData::_internal_mutable_arucomarkers() {
  return &_impl_.arucomarkers_;
}

// repeated .Body bodies = 3;
inline int TrackingData::_internal_bodies_size() const {
  return _impl_.bodies_.size();
}
inline int TrackingData::bodies_size() const {
  return _internal_bodies_size();
}
inline void TrackingData::clear_bodies() {
  _internal_mutable_bodies()->Clear();
}
inline ::Body* TrackingData::mutable_bodies(int index) {
  // @@protoc_insertion_point(field_mutable:TrackingData.bodies)
  return _internal_mutable_bodies()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Body >*
TrackingData::mutable_bodies() {
  // @@protoc_insertion_point(field_mutable_list:TrackingData.bodies)
  return _internal_mutable_bodies();
}
inline const ::Body& TrackingData::_internal_bodies(int index) const {
  return _internal_bodies().Get(index);
}
inline const ::Body& TrackingData::bodies(int index) const {
  // @@protoc_insertion_point(field_get:TrackingData.bodies)
  return _internal_bodies(index);
}
inline ::Body* TrackingData::_internal_add_bodies() {
  return _internal_mutable_bodies()->Add();
}
inline ::Body* TrackingData::add_bodies() {
  ::Body* _add = _internal_add_bodies();
  // @@protoc_insertion_point(field_add:TrackingData.bodies)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Body >&
TrackingData::bodies() const {
  // @@protoc_insertion_point(field_list:TrackingData.bodies)
  return _internal_bodies();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::Body>&
TrackingData::_internal_bodies() const {
  return _impl_.bodies_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::Body>*
TrackingData::_internal_mutable_bodies() {
  return &_impl_.bodies_;
}

// -------------------------------------------------------------------

// ArucoMarker

// string id = 1;
inline void ArucoMarker::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ArucoMarker::id() const {
  // @@protoc_insertion_point(field_get:ArucoMarker.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ArucoMarker::set_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ArucoMarker.id)
}
inline std::string* ArucoMarker::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ArucoMarker.id)
  return _s;
}
inline const std::string& ArucoMarker::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ArucoMarker::_internal_set_id(const std::string& value) {
  ;


  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ArucoMarker::_internal_mutable_id() {
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* ArucoMarker::release_id() {
  // @@protoc_insertion_point(field_release:ArucoMarker.id)
  return _impl_.id_.Release();
}
inline void ArucoMarker::set_allocated_id(std::string* value) {
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ArucoMarker.id)
}

// repeated .Point2f points = 2;
inline int ArucoMarker::_internal_points_size() const {
  return _impl_.points_.size();
}
inline int ArucoMarker::points_size() const {
  return _internal_points_size();
}
inline void ArucoMarker::clear_points() {
  _internal_mutable_points()->Clear();
}
inline ::Point2f* ArucoMarker::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:ArucoMarker.points)
  return _internal_mutable_points()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Point2f >*
ArucoMarker::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:ArucoMarker.points)
  return _internal_mutable_points();
}
inline const ::Point2f& ArucoMarker::_internal_points(int index) const {
  return _internal_points().Get(index);
}
inline const ::Point2f& ArucoMarker::points(int index) const {
  // @@protoc_insertion_point(field_get:ArucoMarker.points)
  return _internal_points(index);
}
inline ::Point2f* ArucoMarker::_internal_add_points() {
  return _internal_mutable_points()->Add();
}
inline ::Point2f* ArucoMarker::add_points() {
  ::Point2f* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:ArucoMarker.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Point2f >&
ArucoMarker::points() const {
  // @@protoc_insertion_point(field_list:ArucoMarker.points)
  return _internal_points();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::Point2f>&
ArucoMarker::_internal_points() const {
  return _impl_.points_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::Point2f>*
ArucoMarker::_internal_mutable_points() {
  return &_impl_.points_;
}

// -------------------------------------------------------------------

// Point2f

// float x = 1;
inline void Point2f::clear_x() {
  _impl_.x_ = 0;
}
inline float Point2f::x() const {
  // @@protoc_insertion_point(field_get:Point2f.x)
  return _internal_x();
}
inline void Point2f::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Point2f.x)
}
inline float Point2f::_internal_x() const {
  return _impl_.x_;
}
inline void Point2f::_internal_set_x(float value) {
  ;
  _impl_.x_ = value;
}

// float y = 2;
inline void Point2f::clear_y() {
  _impl_.y_ = 0;
}
inline float Point2f::y() const {
  // @@protoc_insertion_point(field_get:Point2f.y)
  return _internal_y();
}
inline void Point2f::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Point2f.y)
}
inline float Point2f::_internal_y() const {
  return _impl_.y_;
}
inline void Point2f::_internal_set_y(float value) {
  ;
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// Body

// repeated .Point2f points = 1;
inline int Body::_internal_points_size() const {
  return _impl_.points_.size();
}
inline int Body::points_size() const {
  return _internal_points_size();
}
inline void Body::clear_points() {
  _internal_mutable_points()->Clear();
}
inline ::Point2f* Body::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:Body.points)
  return _internal_mutable_points()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Point2f >*
Body::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:Body.points)
  return _internal_mutable_points();
}
inline const ::Point2f& Body::_internal_points(int index) const {
  return _internal_points().Get(index);
}
inline const ::Point2f& Body::points(int index) const {
  // @@protoc_insertion_point(field_get:Body.points)
  return _internal_points(index);
}
inline ::Point2f* Body::_internal_add_points() {
  return _internal_mutable_points()->Add();
}
inline ::Point2f* Body::add_points() {
  ::Point2f* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:Body.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Point2f >&
Body::points() const {
  // @@protoc_insertion_point(field_list:Body.points)
  return _internal_points();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::Point2f>&
Body::_internal_points() const {
  return _impl_.points_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::Point2f>*
Body::_internal_mutable_points() {
  return &_impl_.points_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_message_2eproto_2epb_2eh
